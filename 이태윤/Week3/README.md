# [문제 해설]

## 수학 - 2720

[알고리즘]
1. 테스트 케이스의 개수 T를 입력받는다.
2. 반복문을 T개수 만큼으로 설정
3. 반복문이 시작될 때마다 거스름돈 C를 입력받는다.
4. 쿼터, 다임, 니켈, 페니의 개수를 각각 0으로 초기화
5. 거스름돈을 동전의 액수로 나누고 해당 동전의 개수를 저장, 남은 거스름돈을 업데이트
6. 동전의 개수를 다 구하면 출력하고 다음 루프로 이동

## 수학 - 3003

[알고리즘]
1. 올바른 피스를 배열로 저장
2. 피스의 개수르 입력받아 배열로 저장
3. 비교하여 차를 계산

## 수학 - 5086

[알고리즘]
1. 입력 받은 수가 모두 0이면 종료
2. 첫 번째가 두 번째의 약수면 facor
3. 첫 번째가 두 번째의 배수면 multiple
4. 약수 배수 둘다 아니면 neither 출력

## 문자열 - 10988

팰린드롬이란? 앞으로 읽을 때와 거꾸로 읽을 때 동일한 단어

[알고리즘]
1. 단어를 입력받는다.
2. 단어를 거꾸로 뒤집은 문자열을 생성, 초기화
3. 하나는 처음부터, 다른 하나는 뒤에서부터 문자열 읽어오기
4. 다르면 bool값으로 체크
5. 다 끝나고 bool값 기준으로 출력

## 문자열 - 1157

[알고리즘]
1. 단어를 입력받는다.
2. 모든 알파벳에 대한 빈도수를 저장하는 리스트를 생성 및 초기화
3. 각 문자에 대해 해당 문자를 대문자로 변환
4. 각 문자에 대해 해당 문자와 알파벳 리스트에서 대응하는 인덱스 값 증가
5. 단어를 다 확인하면 리스트에서 가장 큰 값 찾기, 1개가 아니면 ? 출력

# [팀별 발표]

## 주제 : Set, map 개념 설명 및 define 함수 문법 설명

## [map]

## 1. 정의
(이해를 돕기위한 정의) index로 int가 아닌 다른 자료형을 사용할 수 있는 배열<br/>
각 노드가 key와 value의 쌍으로 이루어진 트리<br/>
검색, 삽입, 삭제 등의 속도를 빠르게 하기 위해 균형 이진 트리 중 하나인 ‘레드 블랙 트리’로 구현<br/>

## 2. 사용법
Map을 사용하기 위해선 <map>을 include 해야함<br/>
중복 불가한 key와 value쌍으로 이루어진 노드의 트리이기에 같은 key값을 갖는 노드를 추가하면 그 노드의 값이 업데이트 됨<br/>
Map은 요소에 접근하는 방식으로 반복자(iterator)와 인덱스(key)를 이용할 수 있다.<br/>

  |멤버 함수|기능|
  |-------|---|
  |m.size()|m의 노드 개수를 리턴|
  |m.empty()|m의 사이즈가 0인지 아닌지를 확인|
  |m.begin()|m의 첫 번째 원소를 가리키는 iterator 리턴|
  |m.end()|m의 마지막 원소를 가리키는 iterator 리턴|
  |m[k] = v |m에 key가 k이고, value가 v인 노드 추가|
  |m.insert(make_pair(k,v))|위와 동일|
  |m.erase(k)|m에서 key가 k인 노드 삭제|
  |m.find(k)|m에서 key가 k인 노드를 찾아, 해당 노드를 가리키는 iterator리턴|
  |m.count(k)|m에서 key가 k인 노드의 개수를 리턴|
  
m.find(k)에서 값이 k인 노드가 존재하지 않는 경우, m의 마지막 원소를 가리키는 iterator 리턴

## [set]
  
## 1. 정의
key만 있는 map

## 2. 사용법

  |멤버 함수|기능|
  |-------|---|
  |s.size()|s의 노드 개수를 리턴|
  |s.empty()|s의 사이즈가 0인지 아닌지를 확인|
  |s.begin()|s의 첫 번째 원소를 가리키는 iterator 리턴|
  |s.end()|s의 마지막 원소를 가리키는 iterator 리턴|
  |s.insert(k)|s에 값이 k인 노드 추가|
  |s.erase(k)|s에서 key가 k인 노드 삭제|
  |s.find(k)|s에서 key가 k인 노드를 찾아, 해당 노드를 가리키는 iterator리턴|
  |s.count(k)|s에서 key가 k인 노드의 개수를 리턴|

  s.find(k)에서 값이 k인 노드가 존재하지 않는 경우, s의 마지막 원소를 가리키는 iterator 리턴
  
## [매크로 함수]  <br/>
  
매크로 함수란, 프로그램 코드 내 특정 문자열을 다른 문자열로 대체하여 컴파일하기 전에 처리하는 기능을 말한다.<br/>

> #define으로 시작되는 전처리 문장을 매크로라고 하며 이를 사용하여 매크로 함수를 만들 수 있다.

[매크로 함수 사용 예제]<br/>
```
#define (매크로 함수 이름) (매크로 함수 기능)
#define ADD(a,b) a+b
```

## [매크로 #연산자]<br/>

> 전처리기 연산자인 #을 활용하면 매크로 함수의 인자를 문자열로 바꿔줄 수 있다.

```
#define ADD1(x,y) x + y
#define ADD2(x,y) #x "+" #y  //문자열로 바꿔주는 연산자 #
```

## [매크로 ##연산자] <br/>
  
> 매크로 함수에서 전처리기 연산자인 ##(토큰 결합 연산자)을 활용하면 매크로 함수의 인자들을 이어붙일 수 있다.
  
```
#define CONCAT(x,y,z) x ## y ## z
```


매크로 코드를 사용하면 긴 코드를 짧게 줄일 수 있고 코드 가독성과 재사용성을 높일 수 있지만, 디버깅이 어렵고 유지보수에 불리하며 매크로 함수가 재귀함수로 사용될 때 성능 저하가 나타난다.
